#+TITLE: Introduction to Python for Applied Calculus
#+AUTHOR: Umberto Fasci
#+DESCRIPTION: Programming now has relevance well beyond just Computer Science. In this module and throughout this course, you will learn not only about programming using Python, but also how to use those skills to solve real, complex problems in future classes, at work, or elsewhere. To ensure this, copious amounts of examples are included, with explanations, throughout the course. You are strongly encouraged not only trace through them, but also experiment with (run, alter, break) them on your own. The assignments are linked to the respective module. Putting time in here will give you the opportunity to solve actual scientific problems and challenge you in a way that that’ll not only help you make use of the skills we’ll discuss in lecture, but also to leave you with that oh-so-satisfying feeling of having conquered the challenge when you’re done!

* Table of Contents :TOC:
- [[#learning-objectives][Learning Objectives]]
- [[#introduction-to-python][Introduction to Python]]
  - [[#how-python-executes-statements][How Python Executes Statements]]
  - [[#variables][Variables]]
  - [[#the-magic-of-python][The Magic of Python]]
  - [[#functions][Functions]]
  - [[#functions-in-action][Functions in Action]]
  - [[#simultaneous-assignment][Simultaneous Assignment]]
  - [[#lists][Lists]]
  - [[#definite-loops][Definite Loops]]
  - [[#range-function][Range Function]]
  - [[#indefinite-loops][Indefinite Loops]]
  - [[#control-statements][Control Statements]]
  - [[#numpy][Numpy]]
- [[#options-for-using-python][Options for Using Python]]

* Learning Objectives

- Assign a value to and perform operations on a Python variable.
- Identify valid and invalid variable names for use in Python.
- Test the truth of expressions in Python using comparison operators.
- Distinguish between the different types of division in Python.
- Perform arithmetic operations in Python.
- Correctly identify the data types in Python, including integers, floating-point numbers, strings, and Boolean values.
- Find a decimal approximation for an irrational number with SymPy.
- Use SymPy to create rational numbers in Python.
- Make a substitution in a symbolic expression using SymPy.
- Define symbol in SymPy to represent a variable in a math expression.
- Describe the differences between symbolic computation and numerical computation.

* Introduction to Python :VIDEO:

** How Python Executes Statements

A Python program is a collection of statements and comments.

*Statements* - an expression for Python to execute.
*Comments* - a note to yourself and those reading your programs, ignored by Python.

#+begin_src python :session
# This is a comment. This is ignored by Python
x = 10
y = 12 # this part is ignored
#+end_src

Python executes lines from top to bottom.

Python does not care about spaces...

#+begin_src python :session
# These two Python statements are equivalent
x = 10
x=10
#+end_src

However, Python does care about capitalization. ~X~ is not the same as ~x~.

** Variables

#+begin_src python :session
x = 3.9
#+end_src

A *variable* stores a value in the computer's memory for use later in the program.
The left side of the ~=~ is the name we want to give to the variable - so we can retrieve it later.
The right side of the ~=~ is the value we want to store in the variable.

In programming ~=~ doesn't mean =equals=. It means =assign=.

#+begin_src python :session
x = 3.9 * x * (1 - x)
#+end_src

The right hand side of the ~=~ could also be a complicated math expression.

However, it could also be a string:

#+begin_src python :session
x = "SOME VALUE"
#+end_src

Variables can be overwritten and updated.

#+begin_src python :session
x = x + 1
#+end_src

** The Magic of Python

Variables can hold any type of data - numbers or text.

#+begin_src python :session
x = "PYTHON IS FUN"
y = 2
z = 3.5
#+end_src

A really nice feature of Python is that we don't have to specify which type of data we are storing.

Other languages don't have this feature.

Another feature of variables in Python is that you can combine variables of the same type without issue.

For example:

#+begin_src python :session
x = 2
y = 3
z = x + y # z has the value 5
#+end_src

OR

#+begin_src python :session
x = "Hello"
y = "World"
z = x + y # z "Hello World"
#+end_src

Problems arise when we try to combine variables of different types.

#+begin_src python :session
x = 2
y = "Hello World"
z = x + y # this will give an error
#+end_src

There are built-in functions in Python to convert from one type to another.
These will be discussed later.

** Functions

A function is a rule for taking zero or more inputs, performing some operations, and the returning an output.

Functions are very useful when you have a repetitive task.

#+begin_src python :session
def double(x):
    x = x*2
    return x
#+end_src

This function is going to double a number and return the results.

*def* is the Python speak for *define a new function*. While *double* is simply an arbitrary name we give to the function.
*(x)* reprents the input of the function. While the ~x = x*2~ is the main statement or workings of the function.
*return x* simply is an instruction of what the function is to return. In this case, the overwritten variable value *x*.

** Functions in Action

To call a function, we can have our function declared as we have done above and then call it by typing its name along with the input.

For example:

#+begin_src python :session
def double(x):
    x = x*2
    return x
#+end_src

#+begin_src python :session
a = double(2)
b = double(3)
c = double(4)
#+end_src

With this (a, b, c) would equal (4, 6, 8) respectivly.

*** Exercise 1

- Write a Python Function that takes three inputs.
- The function should add these three numbers together and return a sum.
- Write a Python statement that will execute the function.
- Use # to add a brief description of what your function is doing.

#+begin_src python :session
def addition(x,y,z):
    # Returns the sum of x, y, and z.
    sum = x + y + z
    return sum
#+end_src

  #+RESULTS:

*** Exercise 2

*Problem*:
- You have a friend studying abroad in a country that lists the temperature in Celsius.
- Your friend is more familiar with Fahrenheit. You'd like to write a program that will do the conversion for your friend.

The Celsius to Fahrenheit conversion equation:

$$F = 9/5 * (C) + 32$$

#+begin_src python :session :results output
def temp_conv(C):
    # Convert Celsius to Fahrenheit.
    F = 9/5 * (C) + 32
    return F
#+end_src

  #+RESULTS:

**** Test Exercise Code

- 0 Celsius is 32.0 degrees Fahrenheit.
- 100 Celsius is 212.0 degrees Fahrenheit.

#+begin_src python :session  :results output verbatim
print(temp_conv(0))
print(temp_conv(100))
#+end_src

*Results:*

32.0
212.0


** Simultaneous Assignment

Some programmers like their programs to be as compact as possible. If this is me, perhaps it is...
then I can assign multiple variable values at once.

<var>, <var>, ... = <expr>, <expr>, ...

#+begin_src python :session
x, y = 10, 15
#+end_src


** Lists

A variable can only hold one value.

#+begin_src python :session
x = 10
#+end_src

A list is a special variable that can hold multiple values.

#+begin_src python :session
x = [54, 76, 100]
#+end_src


** Definite Loops

A /definite/ loop executes a definite number of times, i.e., at the time Python starts the loop it knows
exactly how many /iterations/ to do.

for <var> in <sequence>:
    <body>

The beginning and end of the body are indicated by indentation.

For example:

#+begin_src python :session
values = [54, 76, 100]

for value in values:
    value = value*2
#+end_src

*** Exercise

*Temperature Conversion*

$$F = 9/5 * (C) + 32$$

Use a for loop to convert a list of temps.

#+begin_src python :session
temps = [0, 100, 38]

for temp in temps:
    F = 9/5 * (temp) + 32
#+end_src

** Range Function

What if I don't want to iterate over every value?

The range function also allows us to specify a step size.

#+begin_src python :session
range(start, stop, step)
#+end_src

*** Exercise

Once again using temperature conversion as an example...

Try modifying the program so that it converts all the temperatures from 0 to 100 Celsius in steps of 5.

#+begin_src python :session
for temp in range(0, 100, 5):
    F = 9/5 * (temp) + 32
#+end_src

** Indefinite Loops

The for loop is called a "definite loop" because we know in advance how many times it will execute.

We *definitely* know when it will end.

The opposite is known as an "indefinite loop"

An example of an indefinite loop would be the *while* loop.

This type of loop will execute until a condition is /true/.

For example:

#+begin_src python :session
x = 10
while x < 100:
    x = x + 3

print(x)
#+end_src

This loop will execute continuously until the ~x~ variable is overwritten with a value greater than 100.


** Control Statements

#+begin_src python :session
x = 10

if (x > 5):
    print("Greater than 5") # This will print.
#+end_src

** Numpy

Lists can hold multiple values, but they cannot be treated as vectors.

For example:

#+begin_src python :session
a = [1, 2, 3]
b = [4, 5, 6]

c = a * b # this will generate an error.
#+end_src

With numpy, you can use lists as vectors in a mathematical sense.

For example:

#+begin_src python :session :results output
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

c = a * b

return c
#+end_src

*Results:*

[4, 10, 18]

*** A handy use of lists

#+begin_src python :session
x = []
for i in range(10):
    x.append(i*2)
#+end_src

With empty lists you can, in practice, store results. In this case the result from this code would return a list:

[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]





* Options for Using Python :READING:

This section covers how to install Python, for my purposes I do not need to review this section in such detail.

*Articles provided by the course*:

- [[https://realpython.com/installing-python/][Python 3 Installation & Setup Guide on RealPython]]
- [[https://realpython.com/interacting-with-python/][Interacting with Python on RealPython]]
